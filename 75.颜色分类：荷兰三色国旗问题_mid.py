# 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
# 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
# 注意:不能使用代码库中的排序函数来解决这道题。

# 示例:
# 输入: [2,0,2,1,1,0]
# 输出: [0,0,1,1,2,2]

# 进阶：
# 一个直观的解决方案是使用计数排序的两趟扫描算法。
# 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
# 你能想出一个仅使用常数空间的一趟扫描算法吗？

### Solution: 仅使用常数空间的一趟扫描算法
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        # 荷兰三色国旗问题——红白蓝排序
        # 设定两个指针red\blue分别代表0的右端索引(不包括0)\2的左端索引(不包括2)
        # 遍历列表，每当遇到0时放到0的右端，遇到2时放到2的左端，遇到1时不做处理
        # 当遍历到2的左端索引时，判定结束
        i, red, blue = 0, 0, len(nums)-1
        while i <= blue:
            # 遇到0时
            # 只有0在最前面时，才会出现nums[red]也为0的情况，即nums[i]==nums[red]==0
            # 当i>red后，nums[red]一定是1，所以不需要判定置换后的nums[i]，直接令i+1            
            if nums[i] == 0:
                nums[red], nums[i] = nums[i], nums[red]
                red += 1
                i += 1
            # 遇到2时，因为前后值置换，替换后的值需要再次判定，因此索引i先不进行操作
            elif nums[i] == 2:
                nums[blue], nums[i] = nums[i], nums[blue]
                blue -= 1
            # 遇到1时，不需要进行操作
            else:
                i += 1
